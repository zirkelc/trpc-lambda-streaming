/**
 * @since 1.0.0
 */
import * as Channel from "effect/Channel";
import * as Context from "effect/Context";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as ExecutionStrategy from "effect/ExecutionStrategy";
import * as Exit from "effect/Exit";
import * as FiberRef from "effect/FiberRef";
import * as FiberSet from "effect/FiberSet";
import { dual } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Predicate from "effect/Predicate";
import * as Queue from "effect/Queue";
import * as Scope from "effect/Scope";
import { TypeIdError } from "./Error.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/platform/Socket");
/**
 * @since 1.0.0
 * @category guards
 */
export const isSocket = u => Predicate.hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category tags
 */
export const Socket = /*#__PURE__*/Context.GenericTag("@effect/platform/Socket");
/**
 * @since 1.0.0
 * @category type ids
 */
export const CloseEventTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Socket/CloseEvent");
/**
 * @since 1.0.0
 * @category models
 */
export class CloseEvent {
  code;
  reason;
  /**
   * @since 1.0.0
   */
  [CloseEventTypeId];
  constructor(code = 1000, reason) {
    this.code = code;
    this.reason = reason;
    this[CloseEventTypeId] = CloseEventTypeId;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    return this.reason ? `${this.code}: ${this.reason}` : `${this.code}`;
  }
}
/**
 * @since 1.0.0
 * @category refinements
 */
export const isCloseEvent = u => Predicate.hasProperty(u, CloseEventTypeId);
/**
 * @since 1.0.0
 * @category type ids
 */
export const SocketErrorTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Socket/SocketError");
/**
 * @since 1.0.0
 * @category refinements
 */
export const isSocketError = u => Predicate.hasProperty(u, SocketErrorTypeId);
/**
 * @since 1.0.0
 * @category errors
 */
export class SocketGenericError extends /*#__PURE__*/TypeIdError(SocketErrorTypeId, "SocketError") {
  get message() {
    return `An error occurred during ${this.reason}`;
  }
}
/**
 * @since 1.0.0
 * @category errors
 */
export class SocketCloseError extends /*#__PURE__*/TypeIdError(SocketErrorTypeId, "SocketError") {
  /**
   * @since 1.0.0
   */
  static is(u) {
    return isSocketError(u) && u.reason === "Close";
  }
  /**
   * @since 1.0.0
   */
  static isClean(isClean) {
    return function (u) {
      return SocketCloseError.is(u) && isClean(u.code);
    };
  }
  get message() {
    if (this.closeReason) {
      return `${this.reason}: ${this.code}: ${this.closeReason}`;
    }
    return `${this.reason}: ${this.code}`;
  }
}
/**
 * @since 1.0.0
 * @category combinators
 */
export const toChannelMap = (self, f) => Effect.scope.pipe(Effect.bindTo("scope"), Effect.bind("mailbox", () => Mailbox.make()), Effect.bind("writeScope", ({
  scope
}) => Scope.fork(scope, ExecutionStrategy.sequential)), Effect.bind("write", ({
  writeScope
}) => Scope.extend(self.writer, writeScope)), Effect.let("input", ({
  mailbox,
  write,
  writeScope
}) => ({
  awaitRead: () => Effect.void,
  emit(chunk) {
    return Effect.catchAllCause(Effect.forEach(chunk, write, {
      discard: true
    }), cause => mailbox.failCause(cause));
  },
  error(error) {
    return Effect.zipRight(Scope.close(writeScope, Exit.void), mailbox.failCause(error));
  },
  done() {
    return Scope.close(writeScope, Exit.void);
  }
})), Effect.tap(({
  mailbox,
  scope
}) => self.runRaw(data => {
  mailbox.unsafeOffer(f(data));
}).pipe(Mailbox.into(mailbox), Effect.forkIn(scope), Effect.interruptible)), Effect.map(({
  input,
  mailbox
}) => Channel.embedInput(Mailbox.toChannel(mailbox), input)), Channel.unwrapScoped);
/**
 * @since 1.0.0
 * @category combinators
 */
export const toChannel = self => {
  const encoder = new TextEncoder();
  return toChannelMap(self, data => typeof data === "string" ? encoder.encode(data) : data);
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const toChannelString = /*#__PURE__*/dual(args => isSocket(args[0]), (self, encoding) => {
  const decoder = new TextDecoder(encoding);
  return toChannelMap(self, data => typeof data === "string" ? data : decoder.decode(data));
});
/**
 * @since 1.0.0
 * @category combinators
 */
export const toChannelWith = () => self => toChannel(self);
/**
 * @since 1.0.0
 * @category constructors
 */
export const makeChannel = () => Channel.unwrap(Effect.map(Socket, toChannelWith()));
/**
 * @since 1.0.0
 */
export const defaultCloseCodeIsError = code => code !== 1000 && code !== 1006;
/**
 * @since 1.0.0
 * @category tags
 */
export const WebSocket = /*#__PURE__*/Context.GenericTag("@effect/platform/Socket/WebSocket");
/**
 * @since 1.0.0
 * @category tags
 */
export const WebSocketConstructor = /*#__PURE__*/Context.GenericTag("@effect/platform/Socket/WebSocketConstructor");
/**
 * @since 1.0.0
 * @category layers
 */
export const layerWebSocketConstructorGlobal = /*#__PURE__*/Layer.succeed(WebSocketConstructor, url => new globalThis.WebSocket(url));
/**
 * @since 1.0.0
 * @category constructors
 */
export const makeWebSocket = (url, options) => fromWebSocket(Effect.acquireRelease((typeof url === "string" ? Effect.succeed(url) : url).pipe(Effect.flatMap(url => Effect.map(WebSocketConstructor, f => f(url)))), ws => Effect.sync(() => ws.close())), options);
/**
 * @since 1.0.0
 * @category constructors
 */
export const fromWebSocket = (acquire, options) => Effect.withFiberRuntime(fiber => Effect.map(Queue.dropping(fiber.getFiberRef(currentSendQueueCapacity)), sendQueue => {
  const acquireContext = fiber.getFiberRef(FiberRef.currentContext);
  const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError;
  const runRaw = handler => acquire.pipe(Effect.bindTo("ws"), Effect.bind("fiberSet", () => FiberSet.make()), Effect.bind("run", ({
    fiberSet,
    ws
  }) => Effect.provideService(FiberSet.runtime(fiberSet)(), WebSocket, ws)), Effect.tap(({
    fiberSet,
    run,
    ws
  }) => {
    let open = false;
    function onMessage(event) {
      const result = handler(typeof event.data === "string" ? event.data : event.data instanceof Uint8Array ? event.data : new Uint8Array(event.data));
      if (Effect.isEffect(result)) {
        run(result);
      }
    }
    function onError(cause) {
      ws.removeEventListener("message", onMessage);
      ws.removeEventListener("close", onClose);
      Deferred.unsafeDone(fiberSet.deferred, Effect.fail(new SocketGenericError({
        reason: open ? "Read" : "Open",
        cause
      })));
    }
    function onClose(event) {
      ws.removeEventListener("message", onMessage);
      ws.removeEventListener("error", onError);
      Deferred.unsafeDone(fiberSet.deferred, Effect.fail(new SocketCloseError({
        reason: "Close",
        code: event.code,
        closeReason: event.reason
      })));
    }
    ws.addEventListener("close", onClose, {
      once: true
    });
    ws.addEventListener("error", onError, {
      once: true
    });
    ws.addEventListener("message", onMessage);
    if (ws.readyState !== 1) {
      const openDeferred = Deferred.unsafeMake(fiber.id());
      ws.addEventListener("open", () => {
        open = true;
        Deferred.unsafeDone(openDeferred, Effect.void);
      }, {
        once: true
      });
      return Deferred.await(openDeferred).pipe(Effect.timeoutFail({
        duration: options?.openTimeout ?? 10000,
        onTimeout: () => new SocketGenericError({
          reason: "OpenTimeout",
          cause: "timeout waiting for \"open\""
        })
      }), Effect.raceFirst(FiberSet.join(fiberSet)));
    }
    open = true;
    return Effect.void;
  }), Effect.tap(({
    fiberSet,
    ws
  }) => Queue.take(sendQueue).pipe(Effect.tap(chunk => isCloseEvent(chunk) ? Effect.failSync(() => {
    ws.close(chunk.code, chunk.reason);
    return new SocketCloseError({
      reason: "Close",
      code: chunk.code,
      closeReason: chunk.reason
    });
  }) : Effect.try({
    try: () => ws.send(chunk),
    catch: cause => new SocketGenericError({
      reason: "Write",
      cause
    })
  })), Effect.forever, FiberSet.run(fiberSet))), Effect.tap(({
    fiberSet
  }) => Effect.catchIf(FiberSet.join(fiberSet), SocketCloseError.isClean(_ => !closeCodeIsError(_)), _ => Effect.void)), Effect.mapInputContext(input => Context.merge(acquireContext, input)), Effect.scoped, Effect.interruptible);
  const encoder = new TextEncoder();
  const run = handler => runRaw(data => typeof data === "string" ? handler(encoder.encode(data)) : handler(data));
  const write = chunk => Queue.offer(sendQueue, chunk);
  const writer = Effect.succeed(write);
  return Socket.of({
    [TypeId]: TypeId,
    run,
    runRaw,
    writer
  });
}));
/**
 * @since 1.0.0
 * @category constructors
 */
export const makeWebSocketChannel = (url, options) => Channel.unwrapScoped(Effect.map(makeWebSocket(url, options), toChannelWith()));
/**
 * @since 1.0.0
 * @category layers
 */
export const layerWebSocket = (url, options) => Layer.effect(Socket, makeWebSocket(url, options));
/**
 * @since 1.0.0
 * @category fiber refs
 */
export const currentSendQueueCapacity = /*#__PURE__*/globalValue("@effect/platform/Socket/currentSendQueueCapacity", () => FiberRef.unsafeMake(16));
/**
 * @since 1.0.0
 * @category constructors
 */
export const fromTransformStream = (acquire, options) => {
  const EOF = Symbol();
  return Effect.withFiberRuntime(fiber => Effect.map(Queue.dropping(fiber.getFiberRef(currentSendQueueCapacity)), sendQueue => {
    const acquireContext = fiber.getFiberRef(FiberRef.currentContext);
    const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError;
    const runRaw = handler => acquire.pipe(Effect.bindTo("stream"), Effect.bind("reader", ({
      stream
    }) => Effect.acquireRelease(Effect.sync(() => stream.readable.getReader()), reader => Effect.promise(() => reader.cancel()).pipe(Effect.tap(() => {
      reader.releaseLock();
    })))), Effect.bind("writer", ({
      stream
    }) => Effect.acquireRelease(Effect.sync(() => stream.writable.getWriter()), reader => Effect.sync(() => reader.releaseLock()))), Effect.bind("fiberSet", () => FiberSet.make()), Effect.tap(({
      fiberSet,
      writer
    }) => {
      const encoder = new TextEncoder();
      return Queue.take(sendQueue).pipe(Effect.tap(chunk => {
        if (chunk === EOF || isCloseEvent(chunk)) {
          return Effect.zipRight(Effect.promise(() => writer.close()), chunk === EOF ? Effect.interrupt : Effect.fail(new SocketCloseError({
            reason: "Close",
            code: chunk.code,
            closeReason: chunk.reason
          })));
        }
        return Effect.try({
          try: () => {
            if (typeof chunk === "string") {
              writer.write(encoder.encode(chunk));
            } else {
              writer.write(chunk);
            }
          },
          catch: cause => new SocketGenericError({
            reason: "Write",
            cause
          })
        });
      }), Effect.forever, FiberSet.run(fiberSet));
    }), Effect.tap(({
      fiberSet,
      reader
    }) => Effect.tryPromise({
      try: () => reader.read(),
      catch: cause => new SocketGenericError({
        reason: "Read",
        cause
      })
    }).pipe(Effect.tap(result => {
      if (result.done) {
        return Effect.fail(new SocketCloseError({
          reason: "Close",
          code: 1000
        }));
      }
      return handler(result.value);
    }), Effect.forever, FiberSet.run(fiberSet))), Effect.tap(({
      fiberSet
    }) => Effect.catchIf(FiberSet.join(fiberSet), SocketCloseError.isClean(_ => !closeCodeIsError(_)), _ => Effect.void)), Effect.mapInputContext(input => Context.merge(acquireContext, input)), Effect.scoped, Effect.interruptible);
    const encoder = new TextEncoder();
    const run = handler => runRaw(data => typeof data === "string" ? handler(encoder.encode(data)) : handler(data));
    const write = chunk => Queue.offer(sendQueue, chunk);
    const writer = Effect.acquireRelease(Effect.succeed(write), () => Queue.offer(sendQueue, EOF));
    return Socket.of({
      [TypeId]: TypeId,
      run,
      runRaw,
      writer
    });
  }));
};
//# sourceMappingURL=Socket.js.map