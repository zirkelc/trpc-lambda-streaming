/**
 * @since 1.0.0
 */
import * as AST from "@effect/schema/AST";
import * as ParseResult from "@effect/schema/ParseResult";
import * as Schema from "@effect/schema/Schema";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Encoding from "effect/Encoding";
import * as FiberRef from "effect/FiberRef";
import { identity } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import { pipeArguments } from "effect/Pipeable";
import * as Redacted from "effect/Redacted";
import { unify } from "effect/Unify";
import * as HttpApi from "./HttpApi.js";
import * as HttpApiEndpoint from "./HttpApiEndpoint.js";
import { HttpApiDecodeError } from "./HttpApiError.js";
import * as HttpApiSchema from "./HttpApiSchema.js";
import * as HttpApp from "./HttpApp.js";
import * as HttpMethod from "./HttpMethod.js";
import * as HttpMiddleware from "./HttpMiddleware.js";
import * as HttpRouter from "./HttpRouter.js";
import * as HttpServer from "./HttpServer.js";
import * as HttpServerRequest from "./HttpServerRequest.js";
import * as HttpServerResponse from "./HttpServerResponse.js";
import * as OpenApi from "./OpenApi.js";
/**
 * The router that the API endpoints are attached to.
 *
 * @since 1.0.0
 * @category router
 */
export class Router extends /*#__PURE__*/HttpRouter.Tag("@effect/platform/HttpApiBuilder/Router")() {}
/**
 * Build an `HttpApp` from an `HttpApi` instance, and serve it using an
 * `HttpServer`.
 *
 * Optionally, you can provide a middleware function that will be applied to
 * the `HttpApp` before serving.
 *
 * @since 1.0.0
 * @category constructors
 */
export const serve = middleware => httpApp.pipe(Effect.map(HttpServer.serve(middleware)), Layer.unwrapEffect, Layer.provide(Router.Live));
/**
 * Construct an `HttpApp` from an `HttpApi` instance.
 *
 * @since 1.0.0
 * @category constructors
 */
export const httpApp = /*#__PURE__*/Effect.gen(function* () {
  const api = yield* HttpApi.HttpApi;
  const router = yield* Router.router;
  const apiMiddleware = yield* Effect.serviceOption(Middleware);
  const errorSchema = makeErrorSchema(api);
  const encodeError = Schema.encodeUnknown(errorSchema);
  return router.pipe(apiMiddleware._tag === "Some" ? apiMiddleware.value : identity, Effect.catchAll(error => Effect.matchEffect(encodeError(error), {
    onFailure: () => Effect.die(error),
    onSuccess: Effect.succeed
  })));
});
/**
 * Construct an http web handler from an `HttpApi` instance.
 *
 * @since 1.0.0
 * @category constructors
 * @example
 * import { HttpApi } from "@effect/platform"
 * import { Etag, HttpApiBuilder, HttpMiddleware, HttpPlatform } from "@effect/platform"
 * import { NodeContext } from "@effect/platform-node"
 * import { Layer, ManagedRuntime } from "effect"
 *
 * const ApiLive = HttpApiBuilder.api(HttpApi.empty)
 *
 * const runtime = ManagedRuntime.make(
 *   Layer.mergeAll(
 *     ApiLive,
 *     HttpApiBuilder.Router.Live,
 *     HttpPlatform.layer,
 *     Etag.layerWeak
 *   ).pipe(
 *     Layer.provideMerge(NodeContext.layer)
 *   )
 * )
 *
 * const handler = HttpApiBuilder.toWebHandler(runtime, HttpMiddleware.logger)
 */
export const toWebHandler = (runtime, middleware) => {
  const handlerPromise = httpApp.pipe(Effect.bindTo("httpApp"), Effect.bind("runtime", () => runtime.runtimeEffect), Effect.map(({
    httpApp,
    runtime
  }) => HttpApp.toWebHandlerRuntime(runtime)(middleware ? middleware(httpApp) : httpApp)), runtime.runPromise);
  return request => handlerPromise.then(handler => handler(request));
};
/**
 * Build a root level `Layer` from an `HttpApi` instance.
 *
 * The `Layer` will provide the `HttpApi` service, and will require the
 * implementation for all the `HttpApiGroup`'s contained in the `HttpApi`.
 *
 * The resulting `Layer` can be provided to the `HttpApiBuilder.serve` layer.
 *
 * @since 1.0.0
 * @category constructors
 */
export const api = self => Layer.succeed(HttpApi.HttpApi, self);
/**
 * @since 1.0.0
 * @category handlers
 */
export const HandlersTypeId = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiBuilder/Handlers");
const HandlersProto = {
  [HandlersTypeId]: {
    _Endpoints: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const makeHandlers = options => {
  const self = Object.create(HandlersProto);
  self.group = options.group;
  self.handlers = options.handlers;
  return self;
};
/**
 * Create a `Layer` that will implement all the endpoints in an `HttpApiGroup`.
 *
 * An unimplemented `Handlers` instance is passed to the `build` function, which
 * you can use to add handlers to the group.
 *
 * You can implement endpoints using the `HttpApiBuilder.handle` api.
 *
 * @since 1.0.0
 * @category handlers
 */
export const group = (api, groupName, build) => Router.use(router => Effect.gen(function* () {
  const context = yield* Effect.context();
  const group = Chunk.findFirst(api.groups, group => group.identifier === groupName);
  if (group._tag === "None") {
    throw new Error(`Group "${groupName}" not found in API`);
  }
  const result = build(makeHandlers({
    group: group.value,
    handlers: Chunk.empty()
  }));
  const handlers = Effect.isEffect(result) ? yield* result : result;
  const routes = [];
  for (const item of handlers.handlers) {
    if (item._tag === "Middleware") {
      for (const route of routes) {
        ;
        route.handler = item.middleware(route.handler);
      }
    } else {
      routes.push(handlerToRoute(item.endpoint, function (request) {
        return Effect.mapInputContext(item.handler(request), input => Context.merge(context, input));
      }, item.withFullResponse));
    }
  }
  yield* router.concat(HttpRouter.fromIterable(routes));
}));
/**
 * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.
 *
 * @since 1.0.0
 * @category handlers
 */
export const handle = (name, handler, options) => self => {
  const o = Chunk.findFirst(self.group.endpoints, endpoint => endpoint.name === name);
  if (o._tag === "None") {
    throw new Error(`Endpoint "${name}" not found in group "${self.group.identifier}"`);
  }
  const endpoint = o.value;
  return makeHandlers({
    group: self.group,
    handlers: Chunk.append(self.handlers, {
      _tag: "Handler",
      endpoint,
      handler,
      withFullResponse: options?.withFullResponse === true
    })
  });
};
/**
 * Add `HttpMiddleware` to a `Handlers` group.
 *
 * Any errors are required to have a corresponding schema in the API.
 * You can add middleware errors to an `HttpApiGroup` using the `HttpApiGroup.addError`
 * api.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middleware = middleware => self => makeHandlers({
  ...self,
  handlers: Chunk.append(self.handlers, {
    _tag: "Middleware",
    middleware
  })
});
/**
 * @since 1.0.0
 * @category middleware
 */
export class Middleware extends /*#__PURE__*/Context.Tag("@effect/platform/HttpApiBuilder/Middleware")() {}
const middlewareAdd = middleware => Effect.map(Effect.context(), context => {
  const current = Context.getOption(context, Middleware);
  const withContext = httpApp => Effect.mapInputContext(middleware(httpApp), input => Context.merge(context, input));
  return current._tag === "None" ? withContext : httpApp => withContext(current.value(httpApp));
});
const middlewareAddNoContext = middleware => Effect.map(Effect.serviceOption(Middleware), current => {
  return current._tag === "None" ? middleware : httpApp => middleware(current.value(httpApp));
});
/**
 * Create an `HttpApi` level middleware `Layer`.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middlewareLayer = (...args) => {
  const apiFirst = HttpApi.isHttpApi(args[0]);
  const withContext = apiFirst ? args[2]?.withContext === true : args[1]?.withContext === true;
  const add = withContext ? middlewareAdd : middlewareAddNoContext;
  const middleware = apiFirst ? args[1] : args[0];
  return Effect.isEffect(middleware) ? Layer.effect(Middleware, Effect.flatMap(middleware, add)) : Layer.effect(Middleware, add(middleware));
};
/**
 * Create an `HttpApi` level middleware `Layer`, that has a `Scope` provided to
 * the constructor.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middlewareLayerScoped = (...args) => {
  const apiFirst = HttpApi.isHttpApi(args[0]);
  const withContext = apiFirst ? args[2]?.withContext === true : args[1]?.withContext === true;
  const add = withContext ? middlewareAdd : middlewareAddNoContext;
  const middleware = apiFirst ? args[1] : args[0];
  return Layer.scoped(Middleware, Effect.flatMap(middleware, add));
};
/**
 * A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middlewareCors = options => middlewareLayer(HttpMiddleware.cors(options));
/**
 * A middleware that adds an openapi.json endpoint to the API.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middlewareOpenApi = options => Router.use(router => Effect.gen(function* () {
  const api = yield* HttpApi.HttpApi;
  const spec = OpenApi.fromApi(api);
  const response = yield* HttpServerResponse.json(spec).pipe(Effect.orDie);
  yield* router.get(options?.path ?? "/openapi.json", Effect.succeed(response));
}));
const bearerLen = `Bearer `.length;
/**
 * @since 1.0.0
 * @category middleware
 */
export const securityDecode = self => {
  switch (self._tag) {
    case "Bearer":
      {
        return Effect.map(HttpServerRequest.HttpServerRequest, request => Redacted.make((request.headers.authorization ?? "").slice(bearerLen)));
      }
    case "ApiKey":
      {
        const schema = Schema.Struct({
          [self.key]: Schema.String
        });
        const decode = unify(self.in === "query" ? HttpServerRequest.schemaSearchParams(schema) : self.in === "cookie" ? HttpServerRequest.schemaCookies(schema) : HttpServerRequest.schemaHeaders(schema));
        return Effect.match(decode, {
          onFailure: () => Redacted.make(""),
          onSuccess: match => Redacted.make(match[self.key])
        });
      }
    case "Basic":
      {
        const empty = {
          username: "",
          password: Redacted.make("")
        };
        return HttpServerRequest.HttpServerRequest.pipe(Effect.flatMap(request => Encoding.decodeBase64String(request.headers.authorization ?? "")), Effect.match({
          onFailure: () => empty,
          onSuccess: header => {
            const parts = header.split(":");
            if (parts.length !== 2) {
              return empty;
            }
            return {
              username: parts[0],
              password: Redacted.make(parts[1])
            };
          }
        }));
      }
  }
};
/**
 * Set a cookie from an `HttpApiSecurity.HttpApiKey` instance.
 *
 * You can use this api before returning a response from an endpoint handler.
 *
 * ```ts
 * ApiBuilder.handle(
 *   "authenticate",
 *   (_) => ApiBuilder.securitySetCookie(security, "secret123")
 * )
 * ```
 *
 * @since 1.0.0
 * @category middleware
 */
export const securitySetCookie = (self, value, options) => {
  const stringValue = typeof value === "string" ? value : Redacted.value(value);
  return HttpApp.appendPreResponseHandler((_req, response) => Effect.orDie(HttpServerResponse.setCookie(response, self.key, stringValue, {
    secure: true,
    httpOnly: true,
    ...options
  })));
};
/**
 * Make a middleware from an `HttpApiSecurity` instance, that can be used when
 * constructing a `Handlers` group.
 *
 * @since 1.0.0
 * @category middleware
 * @example
 * import { HttpApiBuilder, HttpApiSecurity } from "@effect/platform"
 * import { Schema } from "@effect/schema"
 * import { Context, Effect, Redacted } from "effect"
 *
 * class User extends Schema.Class<User>("User")({
 *   id: Schema.Number
 * }) {}
 *
 * class CurrentUser extends Context.Tag("CurrentUser")<CurrentUser, User>() {}
 *
 * class Accounts extends Context.Tag("Accounts")<Accounts, {
 *   readonly findUserByAccessToken: (accessToken: string) => Effect.Effect<User>
 * }>() {}
 *
 * const securityMiddleware = Effect.gen(function*() {
 *   const accounts = yield* Accounts
 *   return HttpApiBuilder.middlewareSecurity(
 *     HttpApiSecurity.bearer,
 *     CurrentUser,
 *     (token) => accounts.findUserByAccessToken(Redacted.value(token))
 *   )
 * })
 */
export const middlewareSecurity = (self, tag, f) => middleware(Effect.provideServiceEffect(tag, Effect.flatMap(securityDecode(self), f)));
/**
 * Make a middleware from an `HttpApiSecurity` instance, that can be used when
 * constructing a `Handlers` group.
 *
 * This version does not supply any context to the handlers.
 *
 * @since 1.0.0
 * @category middleware
 */
export const middlewareSecurityVoid = (self, f) => middleware(httpApp => securityDecode(self).pipe(Effect.flatMap(f), Effect.zipRight(httpApp)));
// internal
const requestPayload = (request, urlParams, isMultipart) => HttpMethod.hasBody(request.method) ? isMultipart ? Effect.orDie(request.multipart) : Effect.orDie(request.json) : Effect.succeed(urlParams);
const handlerToRoute = (endpoint, handler, isFullResponse) => {
  const decodePath = Option.map(endpoint.pathSchema, Schema.decodeUnknown);
  const isMultipart = endpoint.payloadSchema.pipe(Option.map(schema => HttpApiSchema.getMultipart(schema.ast)), Option.getOrElse(() => false));
  const decodePayload = Option.map(endpoint.payloadSchema, Schema.decodeUnknown);
  const decodeHeaders = Option.map(endpoint.headersSchema, Schema.decodeUnknown);
  const encoding = HttpApiSchema.getEncoding(endpoint.successSchema.ast);
  const successStatus = HttpApiSchema.getStatusSuccess(endpoint.successSchema);
  const encodeSuccess = Option.map(HttpApiEndpoint.schemaSuccess(endpoint), schema => {
    const encode = Schema.encodeUnknown(schema);
    switch (encoding.kind) {
      case "Json":
        {
          return body => Effect.orDie(Effect.flatMap(encode(body), json => HttpServerResponse.json(json, {
            status: successStatus,
            contentType: encoding.contentType
          })));
        }
      case "Text":
        {
          return body => Effect.map(Effect.orDie(encode(body)), text => HttpServerResponse.text(text, {
            status: successStatus,
            contentType: encoding.contentType
          }));
        }
      case "Uint8Array":
        {
          return body => Effect.map(Effect.orDie(encode(body)), data => HttpServerResponse.uint8Array(data, {
            status: successStatus,
            contentType: encoding.contentType
          }));
        }
      case "UrlParams":
        {
          return body => Effect.map(Effect.orDie(encode(body)), params => HttpServerResponse.urlParams(params, {
            status: successStatus,
            contentType: encoding.contentType
          }));
        }
    }
  });
  return HttpRouter.makeRoute(endpoint.method, endpoint.path, Effect.withFiberRuntime(fiber => {
    const context = fiber.getFiberRef(FiberRef.currentContext);
    const request = Context.unsafeGet(context, HttpServerRequest.HttpServerRequest);
    const routeContext = Context.unsafeGet(context, HttpRouter.RouteContext);
    const urlParams = Context.unsafeGet(context, HttpServerRequest.ParsedSearchParams);
    return (decodePath._tag === "Some" ? Effect.catchAll(decodePath.value(routeContext.params), HttpApiDecodeError.refailParseError) : Effect.succeed(routeContext.params)).pipe(Effect.bindTo("pathParams"), decodePayload._tag === "Some" ? Effect.bind("payload", _ => requestPayload(request, urlParams, isMultipart).pipe(Effect.orDie, Effect.flatMap(raw => Effect.catchAll(decodePayload.value(raw), HttpApiDecodeError.refailParseError)))) : identity, decodeHeaders._tag === "Some" ? Effect.bind("headers", _ => Effect.orDie(decodeHeaders.value(request.headers))) : identity, Effect.flatMap(input => {
      const request = {
        path: input.pathParams
      };
      if ("payload" in input) {
        request.payload = input.payload;
      }
      if ("headers" in input) {
        request.headers = input.headers;
      }
      return handler(request);
    }), isFullResponse ? identity : encodeSuccess._tag === "Some" ? Effect.flatMap(encodeSuccess.value) : Effect.as(HttpServerResponse.empty({
      status: successStatus
    })));
  }));
};
const astCache = /*#__PURE__*/globalValue("@effect/platform/HttpApiBuilder/astCache", () => new WeakMap());
const makeErrorSchema = api => {
  const schemas = new Set();
  function processSchema(schema) {
    if (astCache.has(schema.ast)) {
      schemas.add(astCache.get(schema.ast));
      return;
    }
    const ast = schema.ast;
    if (ast._tag === "Union") {
      for (const astType of ast.types) {
        const errorSchema = Schema.make(astType).annotations({
          ...ast.annotations,
          ...astType.annotations
        });
        astCache.set(astType, errorSchema);
        schemas.add(errorSchema);
      }
    } else {
      astCache.set(ast, schema);
      schemas.add(schema);
    }
  }
  processSchema(api.errorSchema);
  for (const group of api.groups) {
    for (const endpoint of group.endpoints) {
      processSchema(endpoint.errorSchema);
    }
    processSchema(group.errorSchema);
  }
  return Schema.Union(...[...schemas].map(schema => {
    const status = HttpApiSchema.getStatusError(schema);
    const encoded = AST.encodedAST(schema.ast);
    const isEmpty = encoded._tag === "VoidKeyword";
    return Schema.transformOrFail(Schema.Any, schema, {
      decode: (_, __, ast) => ParseResult.fail(new ParseResult.Forbidden(ast, _, "Encode only schema")),
      encode: (error, _, ast) => isEmpty ? HttpServerResponse.empty({
        status
      }) : HttpServerResponse.json(error, {
        status
      }).pipe(Effect.mapError(error => new ParseResult.Type(ast, error, "Could not encode to JSON")))
    });
  }));
};
//# sourceMappingURL=HttpApiBuilder.js.map