/**
 * @since 1.0.0
 */
import * as AST from "@effect/schema/AST";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import { dual } from "effect/Function";
import * as Option from "effect/Option";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as HttpApiEndpoint from "./HttpApiEndpoint.js";
import { HttpApiDecodeError } from "./HttpApiError.js";
import * as HttpApiGroup from "./HttpApiGroup.js";
import * as HttpApiSchema from "./HttpApiSchema.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/platform/HttpApi");
/**
 * @since 1.0.0
 * @category guards
 */
export const isHttpApi = u => Predicate.hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category tags
 */
export const HttpApi = /*#__PURE__*/Context.GenericTag("@effect/platform/HttpApi");
const Proto = {
  [TypeId]: TypeId,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const makeProto = options => {
  function HttpApi() {}
  Object.setPrototypeOf(HttpApi, Proto);
  return Object.assign(HttpApi, options);
};
/**
 * An empty `HttpApi`. You can use this to start building your `HttpApi`.
 *
 * You can add groups to this `HttpApi` using the `addGroup` function.
 *
 * @since 1.0.0
 * @category constructors
 */
export const empty = /*#__PURE__*/makeProto({
  groups: /*#__PURE__*/Chunk.empty(),
  errorSchema: HttpApiDecodeError,
  annotations: /*#__PURE__*/Context.empty()
});
/**
 * Add a `HttpApiGroup` to an `HttpApi`.
 *
 * @since 1.0.0
 * @category constructors
 */
export const addGroup = /*#__PURE__*/dual(args => isHttpApi(args[0]), (self, ...args) => {
  const group = args.length === 1 ? args[0] : HttpApiGroup.prefix(args[1], args[0]);
  return makeProto({
    errorSchema: self.errorSchema,
    annotations: self.annotations,
    groups: Chunk.append(self.groups, group)
  });
});
/**
 * Add an error schema to an `HttpApi`, which is shared by all endpoints in the
 * `HttpApi`.
 *
 * Useful for adding error types from middleware or other shared error types.
 *
 * @since 1.0.0
 * @category errors
 */
export const addError = /*#__PURE__*/dual(args => isHttpApi(args[0]), (self, schema, annotations) => makeProto({
  groups: self.groups,
  annotations: self.annotations,
  errorSchema: HttpApiSchema.UnionUnify(self.errorSchema, schema.annotations(HttpApiSchema.annotations({
    status: annotations?.status ?? HttpApiSchema.getStatusError(schema)
  })))
}));
/**
 * @since 1.0.0
 * @category annotations
 */
export const annotateMerge = /*#__PURE__*/dual(2, (self, context) => makeProto({
  groups: self.groups,
  errorSchema: self.errorSchema,
  annotations: Context.merge(self.annotations, context)
}));
/**
 * @since 1.0.0
 * @category annotations
 */
export const annotate = /*#__PURE__*/dual(3, (self, tag, value) => makeProto({
  groups: self.groups,
  errorSchema: self.errorSchema,
  annotations: Context.add(self.annotations, tag, value)
}));
/**
 * Extract metadata from an `HttpApi`, which can be used to generate documentation
 * or other tooling.
 *
 * See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.
 *
 * @since 1.0.0
 * @category reflection
 */
export const reflect = (self, options) => {
  const apiErrors = extractErrors(self.errorSchema.ast, new Map());
  const groups = self.groups;
  for (const group of groups) {
    const groupErrors = extractErrors(group.errorSchema.ast, apiErrors);
    const groupAnnotations = Context.merge(self.annotations, group.annotations);
    options.onGroup({
      group,
      mergedAnnotations: groupAnnotations
    });
    const endpoints = group.endpoints;
    for (const endpoint of endpoints) {
      options.onEndpoint({
        group,
        endpoint,
        mergedAnnotations: Context.merge(groupAnnotations, endpoint.annotations),
        successAST: HttpApiEndpoint.schemaSuccess(endpoint).pipe(Option.map(schema => schema.ast)),
        successStatus: HttpApiSchema.getStatusSuccess(endpoint.successSchema),
        successEncoding: HttpApiSchema.getEncoding(endpoint.successSchema.ast),
        errors: extractErrors(endpoint.errorSchema.ast, groupErrors)
      });
    }
  }
};
// -------------------------------------------------------------------------------------
const extractErrors = (ast, inherited) => {
  const topStatus = HttpApiSchema.getStatusErrorAST(ast);
  const errors = new Map(inherited);
  function process(ast) {
    if (ast._tag === "NeverKeyword") {
      return;
    }
    const status = HttpApiSchema.getStatus(ast, topStatus);
    const emptyDecodeable = HttpApiSchema.getEmptyDecodeable(ast);
    const current = errors.get(status) ?? Option.none();
    errors.set(status, current.pipe(Option.map(current => AST.Union.make(current._tag === "Union" ? [...current.types, ast] : [current, ast])), Option.orElse(() => !emptyDecodeable && AST.encodedAST(ast)._tag === "VoidKeyword" ? Option.none() : Option.some(ast))));
  }
  if (ast._tag === "Union") {
    for (const type of ast.types) {
      process(type);
    }
  } else {
    process(ast);
  }
  return errors;
};
//# sourceMappingURL=HttpApi.js.map