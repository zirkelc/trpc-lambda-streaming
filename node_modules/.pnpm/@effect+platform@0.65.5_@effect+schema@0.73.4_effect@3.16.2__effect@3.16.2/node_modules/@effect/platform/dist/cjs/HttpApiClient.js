"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = void 0;
var ParseResult = _interopRequireWildcard(require("@effect/schema/ParseResult"));
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Option = _interopRequireWildcard(require("effect/Option"));
var HttpApi = _interopRequireWildcard(require("./HttpApi.js"));
var HttpApiSchema = _interopRequireWildcard(require("./HttpApiSchema.js"));
var HttpClient = _interopRequireWildcard(require("./HttpClient.js"));
var HttpClientError = _interopRequireWildcard(require("./HttpClientError.js"));
var HttpClientRequest = _interopRequireWildcard(require("./HttpClientRequest.js"));
var HttpClientResponse = _interopRequireWildcard(require("./HttpClientResponse.js"));
var HttpMethod = _interopRequireWildcard(require("./HttpMethod.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category constructors
 */
const make = (api, options) => Effect.gen(function* () {
  const context = yield* Effect.context();
  const httpClient = (yield* HttpClient.HttpClient).pipe(options?.baseUrl === undefined ? _Function.identity : HttpClient.mapRequest(HttpClientRequest.prependUrl(options.baseUrl)), options?.transformClient === undefined ? _Function.identity : options.transformClient);
  const client = {};
  HttpApi.reflect(api, {
    onGroup({
      group
    }) {
      client[group.identifier] = {};
    },
    onEndpoint({
      endpoint,
      errors,
      group,
      successAST,
      successEncoding,
      successStatus
    }) {
      const makeUrl = compilePath(endpoint.path);
      const successDecode = successAST.pipe(Option.map(ast => {
        const schema = Schema.make(ast);
        switch (successEncoding.kind) {
          case "Json":
            {
              return HttpClientResponse.schemaBodyJson(schema);
            }
          case "UrlParams":
            {
              return HttpClientResponse.schemaBodyUrlParams(schema);
            }
          case "Uint8Array":
            {
              return response => response.arrayBuffer.pipe(Effect.map(buffer => new Uint8Array(buffer)), Effect.flatMap(Schema.decodeUnknown(schema)));
            }
          case "Text":
            {
              return response => Effect.flatMap(response.text, Schema.decodeUnknown(schema));
            }
        }
      }));
      const handleError = (request, response) => {
        const error = errors.get(response.status);
        if (error === undefined) {
          return Effect.die(new HttpClientError.ResponseError({
            reason: "Decode",
            request,
            response
          }));
        } else if (Option.isNone(error)) {
          return Effect.fail(new HttpClientError.ResponseError({
            reason: "StatusCode",
            request,
            response
          }));
        }
        const decode = Schema.decodeUnknown(Schema.make(error.value));
        return response.text.pipe(Effect.flatMap(text => text === "" ? Effect.void : Effect.try({
          try: () => JSON.parse(text),
          catch: cause => new HttpClientError.ResponseError({
            reason: "Decode",
            request,
            response,
            cause
          })
        })), Effect.flatMap(json => Effect.mapError(decode(json), cause => new HttpClientError.ResponseError({
          reason: "Decode",
          request,
          response,
          cause
        }))), Effect.flatMap(Effect.fail));
      };
      const isMultipart = endpoint.payloadSchema.pipe(Option.map(schema => HttpApiSchema.getMultipart(schema.ast)), Option.getOrElse(() => false));
      const encodePayload = endpoint.payloadSchema.pipe(Option.filter(() => !isMultipart), Option.map(Schema.encodeUnknown));
      const encodeHeaders = endpoint.headersSchema.pipe(Option.map(Schema.encodeUnknown));
      client[group.identifier][endpoint.name] = request => {
        const url = request && request.path ? makeUrl(request && request.path) : endpoint.path;
        const baseRequest = HttpClientRequest.make(endpoint.method)(url);
        return (isMultipart ? Effect.succeed(baseRequest.pipe(HttpClientRequest.bodyFormData(request.payload))) : encodePayload._tag === "Some" ? encodePayload.value(request.payload).pipe(Effect.flatMap(payload => HttpMethod.hasBody(endpoint.method) ? HttpClientRequest.bodyJson(baseRequest, payload) : Effect.succeed(HttpClientRequest.setUrlParams(baseRequest, payload))), Effect.orDie) : Effect.succeed(baseRequest)).pipe(encodeHeaders._tag === "Some" ? Effect.flatMap(httpRequest => encodeHeaders.value(request.headers).pipe(Effect.orDie, Effect.map(headers => HttpClientRequest.setHeaders(httpRequest, headers)))) : _Function.identity, Effect.flatMap(request => Effect.flatMap(httpClient.execute(request), response => response.status !== successStatus ? handleError(request, response) : Effect.succeed(response))), successDecode._tag === "Some" ? Effect.flatMap(successDecode.value) : Effect.asVoid, Effect.scoped, Effect.catchIf(ParseResult.isParseError, Effect.die), Effect.mapInputContext(input => Context.merge(context, input)));
      };
    }
  });
  return client;
});
// ----------------------------------------------------------------------------
exports.make = make;
const paramsRegex = /:(\w+)[^/]*/g;
const compilePath = path => {
  const segments = path.split(paramsRegex);
  const len = segments.length;
  if (len === 1) {
    return _ => path;
  }
  return params => {
    let url = segments[0];
    for (let i = 1; i < len; i++) {
      if (i % 2 === 0) {
        url += segments[i];
      } else {
        url += params[segments[i]];
      }
    }
    return url;
  };
};
//# sourceMappingURL=HttpApiClient.js.map