"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reflect = exports.isHttpApi = exports.empty = exports.annotateMerge = exports.annotate = exports.addGroup = exports.addError = exports.TypeId = exports.HttpApi = void 0;
var AST = _interopRequireWildcard(require("@effect/schema/AST"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Context = _interopRequireWildcard(require("effect/Context"));
var _Function = require("effect/Function");
var Option = _interopRequireWildcard(require("effect/Option"));
var _Pipeable = require("effect/Pipeable");
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var HttpApiEndpoint = _interopRequireWildcard(require("./HttpApiEndpoint.js"));
var _HttpApiError = require("./HttpApiError.js");
var HttpApiGroup = _interopRequireWildcard(require("./HttpApiGroup.js"));
var HttpApiSchema = _interopRequireWildcard(require("./HttpApiSchema.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/platform/HttpApi");
/**
 * @since 1.0.0
 * @category guards
 */
const isHttpApi = u => Predicate.hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category tags
 */
exports.isHttpApi = isHttpApi;
const HttpApi = exports.HttpApi = /*#__PURE__*/Context.GenericTag("@effect/platform/HttpApi");
const Proto = {
  [TypeId]: TypeId,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeProto = options => {
  function HttpApi() {}
  Object.setPrototypeOf(HttpApi, Proto);
  return Object.assign(HttpApi, options);
};
/**
 * An empty `HttpApi`. You can use this to start building your `HttpApi`.
 *
 * You can add groups to this `HttpApi` using the `addGroup` function.
 *
 * @since 1.0.0
 * @category constructors
 */
const empty = exports.empty = /*#__PURE__*/makeProto({
  groups: /*#__PURE__*/Chunk.empty(),
  errorSchema: _HttpApiError.HttpApiDecodeError,
  annotations: /*#__PURE__*/Context.empty()
});
/**
 * Add a `HttpApiGroup` to an `HttpApi`.
 *
 * @since 1.0.0
 * @category constructors
 */
const addGroup = exports.addGroup = /*#__PURE__*/(0, _Function.dual)(args => isHttpApi(args[0]), (self, ...args) => {
  const group = args.length === 1 ? args[0] : HttpApiGroup.prefix(args[1], args[0]);
  return makeProto({
    errorSchema: self.errorSchema,
    annotations: self.annotations,
    groups: Chunk.append(self.groups, group)
  });
});
/**
 * Add an error schema to an `HttpApi`, which is shared by all endpoints in the
 * `HttpApi`.
 *
 * Useful for adding error types from middleware or other shared error types.
 *
 * @since 1.0.0
 * @category errors
 */
const addError = exports.addError = /*#__PURE__*/(0, _Function.dual)(args => isHttpApi(args[0]), (self, schema, annotations) => makeProto({
  groups: self.groups,
  annotations: self.annotations,
  errorSchema: HttpApiSchema.UnionUnify(self.errorSchema, schema.annotations(HttpApiSchema.annotations({
    status: annotations?.status ?? HttpApiSchema.getStatusError(schema)
  })))
}));
/**
 * @since 1.0.0
 * @category annotations
 */
const annotateMerge = exports.annotateMerge = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => makeProto({
  groups: self.groups,
  errorSchema: self.errorSchema,
  annotations: Context.merge(self.annotations, context)
}));
/**
 * @since 1.0.0
 * @category annotations
 */
const annotate = exports.annotate = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, value) => makeProto({
  groups: self.groups,
  errorSchema: self.errorSchema,
  annotations: Context.add(self.annotations, tag, value)
}));
/**
 * Extract metadata from an `HttpApi`, which can be used to generate documentation
 * or other tooling.
 *
 * See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.
 *
 * @since 1.0.0
 * @category reflection
 */
const reflect = (self, options) => {
  const apiErrors = extractErrors(self.errorSchema.ast, new Map());
  const groups = self.groups;
  for (const group of groups) {
    const groupErrors = extractErrors(group.errorSchema.ast, apiErrors);
    const groupAnnotations = Context.merge(self.annotations, group.annotations);
    options.onGroup({
      group,
      mergedAnnotations: groupAnnotations
    });
    const endpoints = group.endpoints;
    for (const endpoint of endpoints) {
      options.onEndpoint({
        group,
        endpoint,
        mergedAnnotations: Context.merge(groupAnnotations, endpoint.annotations),
        successAST: HttpApiEndpoint.schemaSuccess(endpoint).pipe(Option.map(schema => schema.ast)),
        successStatus: HttpApiSchema.getStatusSuccess(endpoint.successSchema),
        successEncoding: HttpApiSchema.getEncoding(endpoint.successSchema.ast),
        errors: extractErrors(endpoint.errorSchema.ast, groupErrors)
      });
    }
  }
};
// -------------------------------------------------------------------------------------
exports.reflect = reflect;
const extractErrors = (ast, inherited) => {
  const topStatus = HttpApiSchema.getStatusErrorAST(ast);
  const errors = new Map(inherited);
  function process(ast) {
    if (ast._tag === "NeverKeyword") {
      return;
    }
    const status = HttpApiSchema.getStatus(ast, topStatus);
    const emptyDecodeable = HttpApiSchema.getEmptyDecodeable(ast);
    const current = errors.get(status) ?? Option.none();
    errors.set(status, current.pipe(Option.map(current => AST.Union.make(current._tag === "Union" ? [...current.types, ast] : [current, ast])), Option.orElse(() => !emptyDecodeable && AST.encodedAST(ast)._tag === "VoidKeyword" ? Option.none() : Option.some(ast))));
  }
  if (ast._tag === "Union") {
    for (const type of ast.types) {
      process(type);
    }
  } else {
    process(ast);
  }
  return errors;
};
//# sourceMappingURL=HttpApi.js.map