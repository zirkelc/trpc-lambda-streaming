"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withEncoding = exports.isVoid = exports.getStatusSuccessAST = exports.getStatusSuccess = exports.getStatusErrorAST = exports.getStatusError = exports.getStatus = exports.getMultipart = exports.getEncoding = exports.getEmptyDecodeable = exports.asEmpty = exports.annotations = exports.UnionUnify = exports.Uint8Array = exports.Text = exports.NoContent = exports.MultipartTypeId = exports.Multipart = exports.Empty = exports.Created = exports.AnnotationStatus = exports.AnnotationMultipart = exports.AnnotationEncoding = exports.AnnotationEmptyDecodeable = exports.Accepted = void 0;
var AST = _interopRequireWildcard(require("@effect/schema/AST"));
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var _Function = require("effect/Function");
var Struct = _interopRequireWildcard(require("effect/Struct"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category annotations
 */
const AnnotationMultipart = exports.AnnotationMultipart = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiSchema/AnnotationMultipart");
/**
 * @since 1.0.0
 * @category annotations
 */
const AnnotationStatus = exports.AnnotationStatus = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiSchema/AnnotationStatus");
/**
 * @since 1.0.0
 * @category annotations
 */
const AnnotationEmptyDecodeable = exports.AnnotationEmptyDecodeable = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiSchema/AnnotationEmptyDecodeable");
/**
 * @since 1.0.0
 * @category annotations
 */
const AnnotationEncoding = exports.AnnotationEncoding = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiSchema/AnnotationEncoding");
const mergedAnnotations = ast => ast._tag === "Transformation" ? {
  ...ast.to.annotations,
  ...ast.annotations
} : ast.annotations;
const getAnnotation = (ast, key) => mergedAnnotations(ast)[key];
/**
 * @since 1.0.0
 * @category annotations
 */
const getStatus = (ast, defaultStatus) => getAnnotation(ast, AnnotationStatus) ?? defaultStatus;
/**
 * @since 1.0.0
 * @category annotations
 */
exports.getStatus = getStatus;
const getEmptyDecodeable = ast => getAnnotation(ast, AnnotationEmptyDecodeable) ?? false;
/**
 * @since 1.0.0
 * @category annotations
 */
exports.getEmptyDecodeable = getEmptyDecodeable;
const getMultipart = ast => getAnnotation(ast, AnnotationMultipart) ?? false;
exports.getMultipart = getMultipart;
const encodingJson = {
  kind: "Json",
  contentType: "application/json"
};
/**
 * @since 1.0.0
 * @category annotations
 */
const getEncoding = ast => getAnnotation(ast, AnnotationEncoding) ?? encodingJson;
/**
 * @since 1.0.0
 * @category annotations
 */
exports.getEncoding = getEncoding;
const annotations = annotations => {
  const result = Struct.omit(annotations, "status");
  if (annotations.status !== undefined) {
    result[AnnotationStatus] = annotations.status;
  }
  return result;
};
/**
 * @since 1.0.0
 * @category reflection
 */
exports.annotations = annotations;
const isVoid = ast => {
  switch (ast._tag) {
    case "VoidKeyword":
      {
        return true;
      }
    case "Transformation":
      {
        return isVoid(ast.from);
      }
    case "Suspend":
      {
        return isVoid(ast.f());
      }
    default:
      {
        return false;
      }
  }
};
/**
 * @since 1.0.0
 * @category reflection
 */
exports.isVoid = isVoid;
const getStatusSuccessAST = ast => getStatus(ast, isVoid(ast) ? 204 : 200);
/**
 * @since 1.0.0
 * @category reflection
 */
exports.getStatusSuccessAST = getStatusSuccessAST;
const getStatusSuccess = self => getStatusSuccessAST(self.ast);
/**
 * @since 1.0.0
 * @category reflection
 */
exports.getStatusSuccess = getStatusSuccess;
const getStatusErrorAST = ast => getStatus(ast, 500);
/**
 * @since 1.0.0
 * @category reflection
 */
exports.getStatusErrorAST = getStatusErrorAST;
const getStatusError = self => getStatusErrorAST(self.ast);
/**
 * @since 1.0.0
 */
exports.getStatusError = getStatusError;
const UnionUnify = (self, that) => {
  const selfTypes = self.ast._tag === "Union" ? self.ast.types : [self.ast];
  const thatTypes = that.ast._tag === "Union" ? that.ast.types : [that.ast];
  return Schema.make(AST.Union.make([...selfTypes, ...thatTypes]));
};
/**
 * @since 1.0.0
 * @category empty response
 */
exports.UnionUnify = UnionUnify;
const Empty = status => Schema.Void.annotations(annotations({
  status
}));
/**
 * @since 1.0.0
 * @category empty response
 */
exports.Empty = Empty;
const asEmpty = exports.asEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => Schema.transform(Schema.Void, Schema.typeSchema(self), {
  decode: options.decode,
  encode: _Function.constVoid
}).annotations(annotations({
  status: options.status,
  [AnnotationEmptyDecodeable]: true
})));
/**
 * @since 1.0.0
 * @category empty response
 */
const Created = exports.Created = /*#__PURE__*/Empty(201);
/**
 * @since 1.0.0
 * @category empty response
 */
const Accepted = exports.Accepted = /*#__PURE__*/Empty(202);
/**
 * @since 1.0.0
 * @category empty response
 */
const NoContent = exports.NoContent = /*#__PURE__*/Empty(204);
/**
 * @since 1.0.0
 * @category multipart
 */
const MultipartTypeId = exports.MultipartTypeId = /*#__PURE__*/Symbol.for("@effect/platform/HttpApiSchema/Multipart");
/**
 * @since 1.0.0
 * @category multipart
 */
const Multipart = self => self.annotations({
  [AnnotationMultipart]: true
});
exports.Multipart = Multipart;
const defaultContentType = encoding => {
  switch (encoding) {
    case "Json":
      {
        return "application/json";
      }
    case "UrlParams":
      {
        return "application/x-www-form-urlencoded";
      }
    case "Uint8Array":
      {
        return "application/octet-stream";
      }
    case "Text":
      {
        return "text/plain";
      }
  }
};
/**
 * @since 1.0.0
 * @category encoding
 */
const withEncoding = exports.withEncoding = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => self.annotations({
  [AnnotationEncoding]: {
    kind: options.kind,
    contentType: options.contentType ?? defaultContentType(options.kind)
  },
  ...(options.kind === "Uint8Array" ? {
    jsonSchema: {
      type: "string",
      format: "binary"
    }
  } : undefined)
}));
/**
 * @since 1.0.0
 * @category encoding
 */
const Text = options => withEncoding(Schema.String, {
  kind: "Text",
  ...options
});
/**
 * @since 1.0.0
 * @category encoding
 */
exports.Text = Text;
const Uint8Array = options => withEncoding(Schema.Uint8ArrayFromSelf, {
  kind: "Uint8Array",
  ...options
});
exports.Uint8Array = Uint8Array;
//# sourceMappingURL=HttpApiSchema.js.map