/**
 * @since 1.0.0
 */
import * as AST from "@effect/schema/AST";
import type * as Schema from "@effect/schema/Schema";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Option from "effect/Option";
import type { Pipeable } from "effect/Pipeable";
import * as HttpApiEndpoint from "./HttpApiEndpoint.js";
import * as HttpApiGroup from "./HttpApiGroup.js";
import * as HttpApiSchema from "./HttpApiSchema.js";
import type { HttpMethod } from "./HttpMethod.js";
import type * as HttpRouter from "./HttpRouter.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category guards
 */
export declare const isHttpApi: (u: unknown) => u is HttpApi<any, any>;
/**
 * An `HttpApi` represents a collection of `HttpApiGroup`s. You can use an `HttpApi` to
 * represent your entire domain.
 *
 * @since 1.0.0
 * @category models
 */
export interface HttpApi<out Groups extends HttpApiGroup.HttpApiGroup.Any = never, in out Error = never, out ErrorR = never> extends Pipeable {
    new (_: never): {};
    readonly [TypeId]: TypeId;
    readonly groups: Chunk.Chunk<Groups>;
    readonly errorSchema: Schema.Schema<Error, unknown, ErrorR>;
    readonly annotations: Context.Context<never>;
}
/**
 * @since 1.0.0
 * @category tags
 */
export declare const HttpApi: Context.Tag<HttpApi.Service, HttpApi.Any>;
/**
 * @since 1.0.0
 * @category models
 */
export declare namespace HttpApi {
    /**
     * @since 1.0.0
     * @category models
     */
    interface Service {
        readonly _: unique symbol;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    interface Any extends Pipeable {
        new (_: never): {};
        readonly [TypeId]: TypeId;
        readonly groups: Chunk.Chunk<HttpApiGroup.HttpApiGroup.Any>;
        readonly errorSchema: Schema.Schema.All;
        readonly annotations: Context.Context<never>;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    type Context<A> = A extends HttpApi<infer _Groups, infer _ApiError, infer _ApiErrorR> ? _ApiErrorR | HttpApiGroup.HttpApiGroup.Context<_Groups> : never;
}
/**
 * An empty `HttpApi`. You can use this to start building your `HttpApi`.
 *
 * You can add groups to this `HttpApi` using the `addGroup` function.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const empty: HttpApi;
/**
 * Add a `HttpApiGroup` to an `HttpApi`.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const addGroup: {
    <Group extends HttpApiGroup.HttpApiGroup.Any>(group: Group): <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR>(self: HttpApi<Groups, Error, ErrorR>) => HttpApi<Groups | Group, Error, ErrorR>;
    <Group extends HttpApiGroup.HttpApiGroup.Any>(path: HttpRouter.PathInput, group: Group): <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR>(self: HttpApi<Groups, Error, ErrorR>) => HttpApi<Groups | Group, Error, ErrorR>;
    <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, Group extends HttpApiGroup.HttpApiGroup.Any>(self: HttpApi<Groups, Error, ErrorR>, group: Group): HttpApi<Groups | Group, Error, ErrorR>;
    <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, Group extends HttpApiGroup.HttpApiGroup.Any>(self: HttpApi<Groups, Error, ErrorR>, path: HttpRouter.PathInput, group: Group): HttpApi<Groups | Group, Error, ErrorR>;
};
/**
 * Add an error schema to an `HttpApi`, which is shared by all endpoints in the
 * `HttpApi`.
 *
 * Useful for adding error types from middleware or other shared error types.
 *
 * @since 1.0.0
 * @category errors
 */
export declare const addError: {
    <A, I, R>(schema: Schema.Schema<A, I, R>, annotations?: {
        readonly status?: number | undefined;
    }): <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR>(self: HttpApi<Groups, Error, ErrorR>) => HttpApi<Groups, Error | A, ErrorR | R>;
    <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, A, I, R>(self: HttpApi<Groups, Error, ErrorR>, schema: Schema.Schema<A, I, R>, annotations?: {
        readonly status?: number | undefined;
    }): HttpApi<Groups, Error | A, ErrorR | R>;
};
/**
 * @since 1.0.0
 * @category annotations
 */
export declare const annotateMerge: {
    <I>(context: Context.Context<I>): <A extends HttpApi.Any>(self: A) => A;
    <A extends HttpApi.Any, I>(self: A, context: Context.Context<I>): A;
};
/**
 * @since 1.0.0
 * @category annotations
 */
export declare const annotate: {
    <I, S>(tag: Context.Tag<I, S>, value: S): <A extends HttpApi.Any>(self: A) => A;
    <A extends HttpApi.Any, I, S>(self: A, tag: Context.Tag<I, S>, value: S): A;
};
/**
 * Extract metadata from an `HttpApi`, which can be used to generate documentation
 * or other tooling.
 *
 * See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.
 *
 * @since 1.0.0
 * @category reflection
 */
export declare const reflect: <Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR>(self: HttpApi<Groups, Error, ErrorR>, options: {
    readonly onGroup: (options: {
        readonly group: HttpApiGroup.HttpApiGroup<string, any>;
        readonly mergedAnnotations: Context.Context<never>;
    }) => void;
    readonly onEndpoint: (options: {
        readonly group: HttpApiGroup.HttpApiGroup<string, any>;
        readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>;
        readonly mergedAnnotations: Context.Context<never>;
        readonly successAST: Option.Option<AST.AST>;
        readonly successStatus: number;
        readonly successEncoding: HttpApiSchema.Encoding;
        readonly errors: ReadonlyMap<number, Option.Option<AST.AST>>;
    }) => void;
}) => void;
//# sourceMappingURL=HttpApi.d.ts.map