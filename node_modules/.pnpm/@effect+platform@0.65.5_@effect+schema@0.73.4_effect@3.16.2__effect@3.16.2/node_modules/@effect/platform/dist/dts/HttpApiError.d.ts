import type * as ParseResult from "@effect/schema/ParseResult";
import * as Schema from "@effect/schema/Schema";
import * as Effect from "effect/Effect";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category schemas
 */
export interface Issue extends Schema.Struct<{
    _tag: Schema.Literal<[
        "Pointer",
        "Unexpected",
        "Missing",
        "Composite",
        "Refinement",
        "Transformation",
        "Type",
        "Forbidden"
    ]>;
    path: PropertyKeysNoSymbol;
    message: typeof Schema.String;
}> {
}
/**
 * @since 1.0.0
 * @category schemas
 */
export interface PropertyKeysNoSymbol extends Schema.transform<Schema.Array$<Schema.Union<[typeof Schema.String, typeof Schema.Number]>>, Schema.Array$<Schema.Union<[typeof Schema.SymbolFromSelf, typeof Schema.String, typeof Schema.Number]>>> {
}
/**
 * @since 1.0.0
 * @category schemas
 */
export declare const PropertyKeysNoSymbol: PropertyKeysNoSymbol;
/**
 * @since 1.0.0
 * @category schemas
 */
export declare const Issue: Issue;
declare const HttpApiDecodeError_base: Schema.TaggedErrorClass<HttpApiDecodeError, "HttpApiDecodeError", {
    readonly _tag: Schema.tag<"HttpApiDecodeError">;
} & {
    issues: Schema.Array$<Issue>;
    message: typeof Schema.String;
}>;
/**
 * @since 1.0.0
 * @category errors
 */
export declare class HttpApiDecodeError extends HttpApiDecodeError_base {
    /**
     * @since 1.0.0
     */
    static fromParseError(error: ParseResult.ParseError): Effect.Effect<HttpApiDecodeError>;
    /**
     * @since 1.0.0
     */
    static refailParseError(error: ParseResult.ParseError): Effect.Effect<never, HttpApiDecodeError>;
}
export {};
//# sourceMappingURL=HttpApiError.d.ts.map