/**
 * @since 1.0.0
 */
import * as Schema from "@effect/schema/Schema";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import { type Pipeable } from "effect/Pipeable";
import * as HttpApiEndpoint from "./HttpApiEndpoint.js";
import type { HttpApiDecodeError } from "./HttpApiError.js";
import type { PathInput } from "./HttpRouter.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category guards
 */
export declare const isHttpApiGroup: (u: unknown) => u is HttpApiGroup.Any;
/**
 * An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
 * represent a portion of your domain.
 *
 * The endpoints can be implemented later using the `HttpApiBuilder.group` api.
 *
 * @since 1.0.0
 * @category models
 */
export interface HttpApiGroup<out Name extends string, out Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All = never, in out Error = HttpApiDecodeError, out ErrorR = never> extends Pipeable {
    new (_: never): {};
    readonly [TypeId]: TypeId;
    readonly identifier: Name;
    readonly endpoints: Chunk.Chunk<Endpoints>;
    readonly errorSchema: Schema.Schema<Error, unknown, ErrorR>;
    readonly annotations: Context.Context<never>;
}
/**
 * @since 1.0.0
 * @category models
 */
export declare namespace HttpApiGroup {
    /**
     * @since 1.0.0
     * @category models
     */
    type Any = HttpApiGroup<any, any, any, any> | HttpApiGroup<any, any, any, never> | HttpApiGroup<any, any, never, never>;
    /**
     * @since 1.0.0
     * @category models
     */
    interface Service<Name extends string> {
        readonly _: unique symbol;
        readonly name: Name;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    type ToService<Group> = Group extends HttpApiGroup<infer Name, infer _Endpoints, infer _Error, infer _ErrorR> ? Service<Name> : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type WithName<Group, Name extends string> = Extract<Group, {
        readonly identifier: Name;
    }>;
    /**
     * @since 1.0.0
     * @category models
     */
    type Endpoints<Group> = Group extends HttpApiGroup<infer _Name, infer _Endpoints, infer _Error, infer _ErrorR> ? _Endpoints : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type EndpointsWithName<Group extends Any, Name extends string> = Endpoints<WithName<Group, Name>>;
    /**
     * @since 1.0.0
     * @category models
     */
    type Error<Group> = Group extends HttpApiGroup<infer _Name, infer _Endpoints, infer _Error, infer _ErrorR> ? _Error : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type ErrorWithName<Group extends Any, Name extends string> = Error<WithName<Group, Name>>;
    /**
     * @since 1.0.0
     * @category models
     */
    type Context<Group> = Group extends HttpApiGroup<infer _Name, infer _Endpoints, infer _Error, infer _ErrorR> ? _ErrorR | HttpApiEndpoint.HttpApiEndpoint.Context<_Endpoints> : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type ContextWithName<Group extends Any, Name extends string> = Context<WithName<Group, Name>>;
}
/**
 * An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
 * represent a portion of your domain.
 *
 * The endpoints can be implemented later using the `HttpApiBuilder.group` api.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <Name extends string>(identifier: Name) => HttpApiGroup<Name>;
/**
 * Add an `HttpApiEndpoint` to an `HttpApiGroup`.
 *
 * @since 1.0.0
 * @category endpoints
 */
export declare const add: {
    <A extends HttpApiEndpoint.HttpApiEndpoint.All>(endpoint: A): <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>) => HttpApiGroup<Name, Endpoints | A, Error, ErrorR>;
    <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR, A extends HttpApiEndpoint.HttpApiEndpoint.All>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>, endpoint: A): HttpApiGroup<Name, Endpoints | A, Error, ErrorR>;
};
/**
 * Add an error schema to an `HttpApiGroup`, which is shared by all endpoints in the
 * group.
 *
 * @since 1.0.0
 * @category errors
 */
export declare const addError: {
    <A, I, R>(schema: Schema.Schema<A, I, R>, annotations?: {
        readonly status?: number | undefined;
    }): <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>) => HttpApiGroup<Name, Endpoints, Error | A, ErrorR | R>;
    <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR, A, I, R>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>, schema: Schema.Schema<A, I, R>, annotations?: {
        readonly status?: number | undefined;
    }): HttpApiGroup<Name, Endpoints, Error | A, ErrorR | R>;
};
/**
 * Add a path prefix to all endpoints in an `HttpApiGroup`. Note that this will only
 * add the prefix to the endpoints before this api is called.
 *
 * @since 1.0.0
 * @category endpoints
 */
export declare const prefix: {
    (prefix: PathInput): <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>) => HttpApiGroup<Name, Endpoints, Error, ErrorR>;
    <Name extends string, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.All, Error, ErrorR>(self: HttpApiGroup<Name, Endpoints, Error, ErrorR>, prefix: PathInput): HttpApiGroup<Name, Endpoints, Error, ErrorR>;
};
/**
 * Merge the annotations of an `HttpApiGroup` with a new context.
 *
 * @since 1.0.0
 * @category annotations
 */
export declare const annotateMerge: {
    <I>(context: Context.Context<I>): <A extends HttpApiGroup.Any>(self: A) => A;
    <A extends HttpApiGroup.Any, I>(self: A, context: Context.Context<I>): A;
};
/**
 * Add an annotation to an `HttpApiGroup`.
 *
 * @since 1.0.0
 * @category annotations
 */
export declare const annotate: {
    <I, S>(tag: Context.Tag<I, S>, value: S): <A extends HttpApiGroup.Any>(self: A) => A;
    <A extends HttpApiGroup.Any, I, S>(self: A, tag: Context.Tag<I, S>, value: S): A;
};
/**
 * For each endpoint in an `HttpApiGroup`, update the annotations with a new
 * context.
 *
 * Note that this will only update the annotations before this api is called.
 *
 * @since 1.0.0
 * @category annotations
 */
export declare const annotateEndpointsMerge: {
    <I>(context: Context.Context<I>): <A extends HttpApiGroup.Any>(self: A) => A;
    <A extends HttpApiGroup.Any, I>(self: A, context: Context.Context<I>): A;
};
/**
 * For each endpoint in an `HttpApiGroup`, add an annotation.
 *
 * Note that this will only add the annotation to the endpoints before this api
 * is called.
 *
 * @since 1.0.0
 * @category annotations
 */
export declare const annotateEndpoints: {
    <I, S>(tag: Context.Tag<I, S>, value: S): <A extends HttpApiGroup.Any>(self: A) => A;
    <A extends HttpApiGroup.Any, I, S>(self: A, tag: Context.Tag<I, S>, value: S): A;
};
//# sourceMappingURL=HttpApiGroup.d.ts.map